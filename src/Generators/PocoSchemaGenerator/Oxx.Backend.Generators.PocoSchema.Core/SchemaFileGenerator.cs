using Oxx.Backend.Generators.PocoSchema.Core.Configuration;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Abstractions;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Events;
using Oxx.Backend.Generators.PocoSchema.Core.Contracts;
using Oxx.Backend.Generators.PocoSchema.Core.Exceptions;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Files;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Schemas.Contracts;
using Oxx.Backend.Generators.PocoSchema.Core.PocoExtractors;

namespace Oxx.Backend.Generators.PocoSchema.Core;

public abstract class SchemaFileGenerator<TSchemaType, TSchemaEventConfiguration>
	where TSchemaType : ISchema
	where TSchemaEventConfiguration : ISchemaEventConfiguration
{
	private readonly ISchemaConfiguration<TSchemaType, TSchemaEventConfiguration> _configuration;
	private readonly ISchemaConverter _schemaConverter;
	private readonly SemaphoreSlim _semaphoreSlim = new(1);
	private readonly IPocoStructureExtractor _pocoStructureExtractor;

	protected SchemaFileGenerator(ISchemaConverter schemaConverter, ISchemaConfiguration<TSchemaType, TSchemaEventConfiguration> configuration, IPocoStructureExtractor pocoStructureExtractor)
	{
		_schemaConverter = schemaConverter;
		_configuration = configuration;
		_pocoStructureExtractor = pocoStructureExtractor;
	}

	public async Task CreateFilesAsync()
	{
		var generationStartedTime = DateTime.Now;
		_configuration.Events.GenerationStarted?.Invoke(this, new GenerationStartedEventArgs(generationStartedTime));

		EnsureDirectoryExists();
		var pocoStructures = _pocoStructureExtractor.GetAll();
		var fileInformations = _schemaConverter.GenerateFileContent(pocoStructures).ToList();

		await GenerateFilesAsync(fileInformations);

		var generationCompletedTime = DateTime.Now;
		_configuration.Events.GenerationCompleted?.Invoke(this, new GenerationCompletedEventArgs(generationStartedTime, generationCompletedTime));
	}
	
	// public async Task CreateFileAsync<TPoco>()
	// {
	// 	var generationStartedTime = DateTime.Now;
	// 	_configuration.Events.GenerationStarted?.Invoke(this, new GenerationStartedEventArgs(generationStartedTime));
	//
	// 	EnsureDirectoryExists();
	// 	var pocoStructure = GetPocoStructure<TPoco>();
	// 	var fileInformation = _schemaConverter.GenerateFileContent(pocoStructure);
	//
	// 	await GenerateFileAsync(fileInformation);
	//
	// 	var generationCompletedTime = DateTime.Now;
	// 	_configuration.Events.GenerationCompleted?.Invoke(this, new GenerationCompletedEventArgs(generationStartedTime, generationCompletedTime));
	// }

	private async Task GenerateFilesAsync(List<FileInformation> contents)
	{
		_configuration.Events.FilesCreating?.Invoke(this, new FilesCreatingEventArgs(contents));

		await Task.WhenAll(contents.Select(fileInformation => Task.Run(async () =>
		{
			var fileCreatingEventArgs = new FileCreatingEventArgs(fileInformation);
			_configuration.Events.FileCreating?.Invoke(this, fileCreatingEventArgs);

			if (!fileCreatingEventArgs.Skip)
			{
				var filePath = Path.Combine(_configuration.OutputDirectory.FullName, fileInformation.Name + _configuration.FullFileExtension);

				await _semaphoreSlim.WaitAsync();
				await File.WriteAllTextAsync(filePath, fileInformation.Content);
				_semaphoreSlim.Release();
			}

			_configuration.Events.FileCreated?.Invoke(this, new FileCreatedEventArgs(fileInformation)
			{
				Skipped = fileCreatingEventArgs.Skip,
			});
		})));

		_configuration.Events.FilesCreated?.Invoke(this, new FilesCreatedEventArgs(contents));
	}

	private void EnsureDirectoryExists()
	{
		if (_configuration.FileDeletionMode is not FileDeletionMode.OverwriteExisting && _configuration.OutputDirectory.Exists)
		{
			var fileInfos = _configuration.OutputDirectory.GetFiles();

			var deletingFilesEventArgs = new DeletingFilesEventArgs(_configuration.OutputDirectory, fileInfos);
			_configuration.Events.DeletingFiles?.Invoke(this, deletingFilesEventArgs);

			if (_configuration.FileDeletionMode is FileDeletionMode.All)
			{
				EnsureOnlyAutoGeneratedFilesExist(_configuration.OutputDirectory, fileInfos);
			}
			
			foreach (var fileInfo in fileInfos)
			{
				fileInfo.Delete();
			}
		}

		_configuration.OutputDirectory.Create();
	}

	private void EnsureOnlyAutoGeneratedFilesExist(DirectoryInfo directoryInfo, IReadOnlyCollection<FileInfo> fileInfos)
	{
		var filesWithInvalidNaming = fileInfos.Where(x => !_configuration.FullFileNamingRegex.IsMatch(x.Name)).ToArray();
		if (filesWithInvalidNaming.Length is 0)
		{
			return;
		}

		var exception = new DirectoryContainsFilesWithIncompatibleNamingException(filesWithInvalidNaming);
		_configuration.Events.DeletingFilesFailed?.Invoke(this, new DeletingFilesFailedEventArgs(directoryInfo, fileInfos, exception));
		Environment.Exit(1);
	}
}