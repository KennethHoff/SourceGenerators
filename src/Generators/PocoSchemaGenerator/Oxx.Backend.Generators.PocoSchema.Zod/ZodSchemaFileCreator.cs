using Oxx.Backend.Generators.PocoSchema.Core.Configuration;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Abstractions;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Events;
using Oxx.Backend.Generators.PocoSchema.Core.Exceptions;
using Oxx.Backend.Generators.PocoSchema.Core.Logic.FileCreation;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Files;
using Oxx.Backend.Generators.PocoSchema.Zod.Configuration;

namespace Oxx.Backend.Generators.PocoSchema.Zod;

internal sealed class ZodSchemaFileCreator : ISchemaFileCreator
{
	private readonly ISchemaConfiguration<ZodSchemaEvents> _configuration;

	public ZodSchemaFileCreator(ISchemaConfiguration<ZodSchemaEvents> configuration)
	{
		_configuration = configuration;
	}

	public async Task CreateFilesAsync(IEnumerable<FileInformation> fileInformations)
	{
		EnsureDirectoriesExists();
		var readOnlyCollection = fileInformations.ToArray();

		_configuration.Events.FilesCreating?.Invoke(this, new FilesCreatingEventArgs(readOnlyCollection));
		await Task.WhenAll(readOnlyCollection.Select(CreateFileAsync));
		_configuration.Events.FilesCreated?.Invoke(this, new FilesCreatedEventArgs(readOnlyCollection));
	}

	public async Task CreateFileAsync(FileInformation fileInformation)
	{
		var fileCreatingEventArgs = new FileCreatingEventArgs(fileInformation);
		_configuration.Events.FileCreating?.Invoke(this, fileCreatingEventArgs);

		if (!fileCreatingEventArgs.Skip)
		{
			var filePath = Path.Combine(fileInformation.OutputDirectory.FullName, fileInformation.Name + _configuration.FullFileExtension);
			
			await File.WriteAllTextAsync(filePath, fileInformation.Content);
		}

		_configuration.Events.FileCreated?.Invoke(this, new FileCreatedEventArgs(fileInformation)
		{
			Skipped = fileCreatingEventArgs.Skip,
		});
	}

	private void EnsureDirectoriesExists()
	{
		var directoryConfiguration = _configuration.DirectoryOutputConfiguration;
		directoryConfiguration.RootDirectoryInfo.Create();
		directoryConfiguration.AtomicsDirectoryInfo.Create();
		directoryConfiguration.EnumsDirectoryInfo.Create();
		directoryConfiguration.MoleculesDirectoryInfo.Create();
		if (_configuration.FileDeletionMode is FileDeletionMode.OverwriteExisting)
		{
			return;
		}
		
		EnsureDirectoryIsEmpty(directoryConfiguration.RootDirectoryInfo);
		EnsureDirectoryIsEmpty(directoryConfiguration.AtomicsDirectoryInfo);
		EnsureDirectoryIsEmpty(directoryConfiguration.EnumsDirectoryInfo);
		EnsureDirectoryIsEmpty(directoryConfiguration.MoleculesDirectoryInfo);
	}

	private void EnsureDirectoryIsEmpty(DirectoryInfo directoryInfo)
	{
		var fileInfos = directoryInfo.GetFiles();

		var deletingFilesEventArgs = new DeletingFilesEventArgs(directoryInfo, fileInfos);
		_configuration.Events.DeletingFiles?.Invoke(this, deletingFilesEventArgs);

		if (_configuration.FileDeletionMode is FileDeletionMode.All)
		{
			EnsureOnlyAutoGeneratedFilesExist(directoryInfo, fileInfos);
		}

		foreach (var fileInfo in fileInfos)
		{
			fileInfo.Delete();
		}
	}

	private void EnsureOnlyAutoGeneratedFilesExist(DirectoryInfo directoryInfo, IReadOnlyCollection<FileInfo> fileInfos)
	{
		var filesWithInvalidNaming = fileInfos.Where(x => !_configuration.FullFileNamingRegex.IsMatch(x.Name)).ToArray();
		if (filesWithInvalidNaming.Length is 0)
		{
			return;
		}

		var exception = new DirectoryContainsFilesWithIncompatibleNamingException(filesWithInvalidNaming);
		_configuration.Events.DeletingFilesFailed?.Invoke(this, new DeletingFilesFailedEventArgs(directoryInfo, fileInfos, exception));
		Environment.Exit(1);
	}
}
