using Oxx.Backend.Generators.PocoSchema.Core.Configuration;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Abstractions;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Events;
using Oxx.Backend.Generators.PocoSchema.Core.Exceptions;
using Oxx.Backend.Generators.PocoSchema.Core.Logic.FileCreation;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Files;
using Oxx.Backend.Generators.PocoSchema.Zod.Configuration;

namespace Oxx.Backend.Generators.PocoSchema.Zod;

internal sealed class ZodSchemaFileCreator : ISchemaFileCreator
{
	private readonly ISchemaConfiguration<ZodSchemaEvents, ZodDirectoryOutputConfiguration> _configuration;

	public ZodSchemaFileCreator(ISchemaConfiguration<ZodSchemaEvents, ZodDirectoryOutputConfiguration> configuration)
	{
		_configuration = configuration;
	}

	public async Task CreateFilesAsync(IEnumerable<FileInformation> fileInformations)
	{
		EnsureDirectoriesExists();
		var readOnlyCollection = fileInformations.ToArray();

		_configuration.Events.FilesCreating?.Invoke(this, new FilesCreatingEventArgs(readOnlyCollection));
		await Task.WhenAll(readOnlyCollection.Select(CreateFileAsync));
		_configuration.Events.FilesCreated?.Invoke(this, new FilesCreatedEventArgs(readOnlyCollection));
	}

	public async Task CreateFileAsync(FileInformation fileInformation)
	{
		var fileCreatingEventArgs = new FileCreatingEventArgs(fileInformation);
		_configuration.Events.FileCreating?.Invoke(this, fileCreatingEventArgs);

		if (!fileCreatingEventArgs.Skip)
		{
			var filePath = Path.Combine(fileInformation.OutputDirectory.FullName, fileInformation.Name + _configuration.FullFileExtension);
			
			await File.WriteAllTextAsync(filePath, fileInformation.Content);
		}

		_configuration.Events.FileCreated?.Invoke(this, new FileCreatedEventArgs(fileInformation)
		{
			Skipped = fileCreatingEventArgs.Skip,
		});
	}

	private void EnsureDirectoriesExists()
	{
		var directoryConfiguration = _configuration.DirectoryOutputConfiguration;
		
		var directories = new[]
		{
			directoryConfiguration.RootDirectoryInfo,
			directoryConfiguration.AtomsDirectoryInfo,
			directoryConfiguration.EnumsDirectoryInfo,
			directoryConfiguration.MoleculesDirectoryInfo,
		};

		if (_configuration.FileDeletionMode is FileDeletionMode.All or FileDeletionMode.ForcedAll)
		{
			var filesTopLevelDirectoryDictionary = directories
				.ToDictionary(directory => directory, directory => directory.Exists
					? directory.GetFiles()
					: Array.Empty<FileInfo>());

			EnsureDirectoriesAreEmpty(filesTopLevelDirectoryDictionary);
		}
		foreach (var directoryInfo in directories)
		{
			directoryInfo.Create();
		}
	}

	private void EnsureDirectoriesAreEmpty(Dictionary<DirectoryInfo, FileInfo[]> dictionary)
	{
		var deletingFilesEventArgs = new DeletingFilesEventArgs(dictionary);
		_configuration.Events.DeletingFiles?.Invoke(this, deletingFilesEventArgs);

		if (_configuration.FileDeletionMode is FileDeletionMode.All)
		{
			EnsureOnlyAutoGeneratedFilesExist(dictionary);
		}
		
		var rootDirectory = _configuration.DirectoryOutputConfiguration.RootDirectoryInfo;
		if (rootDirectory.Exists)
		{
			rootDirectory.Delete(true);
		}
	}

	private void EnsureOnlyAutoGeneratedFilesExist(DirectoryInfo directoryInfo, IReadOnlyCollection<FileInfo> fileInfos)
	{
		var filesWithInvalidNaming = fileInfos.Where(x => !_configuration.FullFileNamingRegex.IsMatch(x.Name)).ToArray();
		if (filesWithInvalidNaming.Length is 0)
		{
			return;
		}

		var exception = new DirectoryContainsFilesWithIncompatibleNamingException(filesWithInvalidNaming);
		_configuration.Events.DeletingFilesFailed?.Invoke(this, new DeletingFilesFailedEventArgs(directoryInfo, fileInfos, exception));
		Environment.Exit(1);
	}

	private void EnsureOnlyAutoGeneratedFilesExist(Dictionary<DirectoryInfo, FileInfo[]> directoryInfo)
	{
		foreach (var (directory, files) in directoryInfo)
		{
			EnsureOnlyAutoGeneratedFilesExist(directory, files);
		}
	}
}
