using System.Diagnostics;
using System.Globalization;
using Oxx.Backend.Generators.PocoSchema.Core.Contracts;
using Oxx.Backend.Generators.PocoSchema.Core.Models;
using Oxx.Backend.Generators.PocoSchema.Zod.Configuration;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.Abstractions;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.Contracts;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.Contracts.Models;

namespace Oxx.Backend.Generators.PocoSchema.Zod;

public class ZodSchemaConverter : ISchemaConverter
{
	private static readonly string StandardHeader = $$"""
		// This file is autogenerated by Oxx.Backend.Generators.PocoSchema.Zod
		// Version: {{typeof(ZodSchemaConverter).Assembly.GetName().Version}}
		// Date: {{DateOnly.FromDateTime(DateTime.Now).ToString("O", DateTimeFormatInfo.InvariantInfo)}}
		// Do not edit this file manually

		import { z } from "zod";
		""";

	private readonly ZodSchemaConfiguration _configuration;

	private readonly IDictionary<Type, IPartialZodSchema> _generatedSchemas = new Dictionary<Type, IPartialZodSchema>();

	public ZodSchemaConverter(ZodSchemaConfiguration configuration)
	{
		_configuration = configuration;
	}

	#region Interface implementations

	public IEnumerable<FileInformation> GenerateFileContent(IEnumerable<PocoObject> pocoObjects)
	{
		var atoms = GenerateAtoms(_configuration.SchemaDictionary);
		var molecules = GenerateMolecules(pocoObjects);
		return atoms.Concat(molecules).Where(x => x != FileInformation.None);
	}

	#endregion

	private FileInformation GenerateAtom(KeyValuePair<Type, IPartialZodSchema> atomicSchema)
	{
		_generatedSchemas.Add(atomicSchema.Key, atomicSchema.Value);

		if (atomicSchema.Value is IBuiltInAtomicZodSchema)
		{
			return FileInformation.None;
		}

		return new FileInformation
		{
			Content = GenerateFileContent(atomicSchema.Value),
			Name = GenerateFileName(atomicSchema.Value),
		};
	}

	private IEnumerable<FileInformation> GenerateAtoms(IDictionary<Type, IPartialZodSchema> configurationAtomicSchemaDictionary)
		=> configurationAtomicSchemaDictionary
			.Select(GenerateAtom);

	private FileContent GenerateFileContent(IPartialZodSchema schemaValue)
		=> schemaValue switch
		{
			IAtomicZodSchema atomicZodSchema       => GenerateAtomicFileContent(atomicZodSchema),
			IMolecularZodSchema molecularZodSchema => GenerateMolecularFileContent(molecularZodSchema),
			_                                      => FileContent.None,
		};

	private FileContent GenerateAtomicFileContent(IAtomicZodSchema atomicZodSchema)
		=> new($$"""
		{{StandardHeader}}

		export const {{_configuration.FormatSchemaName(atomicZodSchema)}} = {{atomicZodSchema.SchemaDefinition}};

		export type {{_configuration.FormatSchemaTypeName(atomicZodSchema)}} = z.infer<typeof {{_configuration.FormatSchemaName(atomicZodSchema)}}>;

		""");

	private FileContent GenerateMolecularFileContent(IMolecularZodSchema molecularZodSchema)
		=> new($$"""
		{{StandardHeader}}
		{{molecularZodSchema.AdditionalImportsString}}
		
		export const {{_configuration.FormatSchemaName(molecularZodSchema)}} = {{molecularZodSchema.SchemaDefinition}};

		export type {{_configuration.FormatSchemaTypeName(molecularZodSchema)}} = z.infer<typeof {{_configuration.FormatSchemaName(molecularZodSchema)}}>;

		""");

	private FileName GenerateFileName(IPartialZodSchema schemaValue)
		=> new(string.Format(_configuration.SchemaFileNameFormat, schemaValue.SchemaBaseName));

	private FileInformation GenerateMolecule(PocoObject pocoObject)
	{
		var molecularSchema = GenerateMolecularSchema(pocoObject);
		
		return new FileInformation
		{
			Content = GenerateFileContent(molecularSchema),
			Name = GenerateFileName(molecularSchema),
		};
	}

	private IMolecularZodSchema GenerateMolecularSchema(PocoObject pocoObject)
	{
		var partialSchema = _generatedSchemas[pocoObject.Type] switch
		{
			PartialMolecularZodSchema schema => schema,
			IZodSchema schema                => throw new UnreachableException($"Unexpected schema type. {pocoObject.TypeName} has already been generated as {schema.GetType().Name}"),
			_                                => throw new UnreachableException("Schema should have been generated before this point"),
		};

		var validSchemas = pocoObject.Properties
			.Where(x =>
			{
				var propertyType = x.PropertyType;
				
				// If the propertyType is generic, we need to get the generic type definition
				if (propertyType.IsGenericType)
				{
					return _configuration.GenericSchemaDictionary.ContainsKey(propertyType.GetGenericTypeDefinition());
				}
				return _generatedSchemas.ContainsKey(propertyType);
			})
			.Select(x =>
			{
				var propertyType = x.PropertyType;

				// If the propertyType is generic, we need to get the generic type definition
				if (propertyType.IsGenericType)
				{
					var genericSchema = _configuration.CreateGenericSchema(x);
					if (genericSchema is null)
					{
						throw new InvalidOperationException($"No generic schema found for {propertyType.GetGenericTypeDefinition().Name}");
					}
					return KeyValuePair.Create(x, genericSchema);
				}

				var partialZodSchema = _generatedSchemas[propertyType];
				return KeyValuePair.Create(x, partialZodSchema);
			})
			.ToDictionary(x => x.Key, x => x.Value);

		return partialSchema.Populate(validSchemas, _configuration);
	}

	private IEnumerable<FileInformation> GenerateMolecules(IEnumerable<PocoObject> pocoObjects)
		=> pocoObjects
			.Select(GenerateMoleculeDefinition)
			.ToArray()
			.Select(GenerateMolecule);

	/// <summary>
	/// In order to prevent circular dependencies, we need to generate the molecule definitions first.
	/// </summary>
	private PocoObject GenerateMoleculeDefinition(PocoObject pocoObject)
	{
		if (!_generatedSchemas.ContainsKey(pocoObject.Type))
		{
			_generatedSchemas.Add(pocoObject.Type, new PartialMolecularZodSchema
			{
				SchemaBaseName = new SchemaBaseName(pocoObject.TypeName),
			});
		}
		return pocoObject;
	}
}