using System.Diagnostics;
using System.Globalization;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Events;
using Oxx.Backend.Generators.PocoSchema.Core.Configuration.Events.Models;
using Oxx.Backend.Generators.PocoSchema.Core.Contracts;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Files;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Pocos;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Pocos.Contracts;
using Oxx.Backend.Generators.PocoSchema.Core.Models.Types;
using Oxx.Backend.Generators.PocoSchema.Zod.Configuration;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.Abstractions;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.BuiltIn;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.BuiltIn.Contracts;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.Contracts;
using Oxx.Backend.Generators.PocoSchema.Zod.SchemaTypes.Contracts.Models;

namespace Oxx.Backend.Generators.PocoSchema.Zod;

public class ZodSchemaConverter : ISchemaConverter
{
	private static readonly string StandardHeader = $$"""
		// This file is autogenerated by Oxx.Backend.Generators.PocoSchema.Zod
		// Version: {{typeof(ZodSchemaConverter).Assembly.GetName().Version}}
		// Date: {{DateOnly.FromDateTime(DateTime.Now).ToString("O", DateTimeFormatInfo.InvariantInfo)}}
		// Do not edit this file manually

		import { z } from "zod";
		""";

	private readonly ZodSchemaConfiguration _configuration;

	private readonly TypeSchemaDictionary<IPartialZodSchema> _generatedSchemas = new();

	public ZodSchemaConverter(ZodSchemaConfiguration configuration)
	{
		_configuration = configuration;
	}

	#region Interface implementations

	public IEnumerable<FileInformation> GenerateFileContent(IReadOnlyCollection<IPocoStructure> pocoStructures)
	{
		var atoms = GenerateAtoms(_configuration.AtomicSchemasToCreateDictionary);
		var enums = GenerateEnums(pocoStructures.OfType<PocoEnum>());
		var objects = GenerateObjects(pocoStructures.OfType<PocoObject>());

		_configuration.CreatedSchemasDictionary = _generatedSchemas;
		return atoms
			.Concat(enums)
			.Concat(objects)
			.Where(x => x != FileInformation.None);
	}

	#endregion

	private FileInformation GenerateAtom(KeyValuePair<Type, IPartialZodSchema> atomicSchema)
	{
		_generatedSchemas.Add(atomicSchema.Key, atomicSchema.Value);

		if (atomicSchema.Value is IBuiltInAtomicZodSchema)
		{
			return FileInformation.None;
		}

		return new FileInformation
		{
			Content = GenerateFileContent(atomicSchema.Value),
			Name = GenerateFileName(atomicSchema.Value),
		};
	}

	private FileContent GenerateAtomicFileContent(IAtomicZodSchema atomicZodSchema)
		=> new($$"""
		{{StandardHeader}}

		export const {{_configuration.FormatSchemaName(atomicZodSchema)}} = {{atomicZodSchema.SchemaDefinition}};

		export type {{_configuration.FormatSchemaTypeName(atomicZodSchema)}} = z.infer<typeof {{_configuration.FormatSchemaName(atomicZodSchema)}}>;

		""");

	private IEnumerable<FileInformation> GenerateAtoms(TypeSchemaDictionary<IPartialZodSchema> configurationAtomicSchemaDictionary)
		=> configurationAtomicSchemaDictionary
			.Select(GenerateAtom)
			.ToArray();

	private FileInformation GenerateEnum(PocoEnum pocoEnum)
	{
		var enumSchema = new EnumZodSchema(pocoEnum.EnumType);
		_generatedSchemas.Add(pocoEnum.EnumType, enumSchema);

		var generateEnum = new FileInformation
		{
			Content = GenerateFileContent(enumSchema),
			Name = GenerateFileName(enumSchema),
		};

		return generateEnum;
	}

	private FileContent GenerateEnumFileContent(IEnumZodSchema enumZodSchema)
		=> new($$"""
		{{StandardHeader}}

		export enum {{_configuration.FormatEnumName(enumZodSchema)}} {
		{{enumZodSchema.EnumValuesString}},
		}

		export const {{_configuration.FormatSchemaName(enumZodSchema)}} = z.union(
		[z.nativeEnum({{_configuration.FormatEnumName(enumZodSchema)}}), z.union([{{string.Join(", ", enumZodSchema.EnumValuesWithNames.Select(x => $"z.literal(\"{x.Name}\")"))}}])])
		.transform((arg) =>
		{
			if (typeof arg === "string")
			{
				return {{_configuration.FormatEnumName(enumZodSchema)}}[arg];
			}
			return arg;
		});

		export type {{_configuration.FormatSchemaTypeName(enumZodSchema)}} = z.infer<typeof {{_configuration.FormatSchemaName(enumZodSchema)}}>;
		""");

	private IEnumerable<FileInformation> GenerateEnums(IEnumerable<PocoEnum> pocoEnums)
	{
		var enums = pocoEnums
			.Select(GenerateEnum)
			.ToArray();

		return enums;
	}


	private FileContent GenerateFileContent(IPartialZodSchema schemaValue)
		=> schemaValue switch
		{
			IEnumZodSchema enumZodSchema           => GenerateEnumFileContent(enumZodSchema),
			IAtomicZodSchema atomicZodSchema       => GenerateAtomicFileContent(atomicZodSchema),
			IMolecularZodSchema molecularZodSchema => GenerateMolecularFileContent(molecularZodSchema),
			_                                      => FileContent.None,
		};

	private FileName GenerateFileName(IPartialZodSchema schemaValue)
		=> new(string.Format(_configuration.SchemaFileNameFormat, schemaValue.SchemaBaseName));

	private FileContent GenerateMolecularFileContent(IMolecularZodSchema molecularZodSchema)
		=> new($$"""
		{{StandardHeader}}
		{{molecularZodSchema.AdditionalImportsString}}
		
		export const {{_configuration.FormatSchemaName(molecularZodSchema)}} = {{molecularZodSchema.SchemaDefinition}};

		export type {{_configuration.FormatSchemaTypeName(molecularZodSchema)}} = z.infer<typeof {{_configuration.FormatSchemaName(molecularZodSchema)}}>;

		""");

	private (IMolecularZodSchema Schema, IReadOnlyCollection<SchemaMemberInfo> InvalidProperties) GenerateMolecularSchema(PocoObject pocoObject)
	{
		var partialSchema = _generatedSchemas[pocoObject.ObjectType] switch
		{
			PartialMolecularZodSchema schema => schema,
			IZodSchema schema => throw new UnreachableException(
				$"Unexpected schema type. {pocoObject.TypeName} has already been generated as {schema.GetType().Name}"),
			_ => throw new UnreachableException("Schema should have been generated before this point"),
		};

		var validSchemas = pocoObject.SchemaMembers
			.Where(x =>
			{
				var propertyType = x.Type;

				if (_generatedSchemas.HasSchemaForType(propertyType))
				{
					return true;
				}

				// Edge case for Arrays using the funky [] syntax
				if (propertyType.IsArray && _generatedSchemas.HasSchemaForType(propertyType.GetElementType()!))
				{
					return true;
				}

				// If the propertyType is generic, we need to get the generic type definition
				if (propertyType.IsGenericType)
				{
					var hasRelatedType = _configuration.GenericSchemasDictionary.HasRelatedType(propertyType.GetGenericTypeDefinition());
					var allGenericArgumentsHaveSchema = propertyType.GetGenericArguments().All(_generatedSchemas.HasSchemaForType);
					return hasRelatedType && allGenericArgumentsHaveSchema;
				}

				return false;
			})
			.Select(x =>
			{
				var propertyType = x.Type;

				var partialZodSchema = _generatedSchemas.GetSchemaForType(propertyType);
				if (partialZodSchema is not null)
				{
					return KeyValuePair.Create(x, partialZodSchema);
				}

				// Edge case for Arrays using the funky [] syntax
				if (propertyType.IsArray)
				{
					var arraySchema = _configuration.CreateArraySchema(x);
					return KeyValuePair.Create(x, arraySchema);
				}

				// If the propertyType is generic, we need to get the generic type definition
				if (propertyType.IsGenericType)
				{
					var genericSchema = _configuration.CreateGenericSchema(x);
					return KeyValuePair.Create(x, genericSchema);
				}

				throw new InvalidOperationException($"No schema found for {propertyType.Name}");
			})
			.ToDictionary(x => x.Key, x => x.Value);

		var invalidProperties = pocoObject.SchemaMembers
			.Where(x => !validSchemas.ContainsKey(x))
			.ToArray();

		return (partialSchema.Populate(validSchemas, _configuration), invalidProperties);
	}

	private (FileInformation FileInformation, CreatedSchemaInformation SchemaInformation) GenerateMolecule(PocoObject pocoObject)
	{
		var (molecularSchema, invalidProperties) = GenerateMolecularSchema(pocoObject);

		_generatedSchemas.Update(pocoObject.ObjectType, molecularSchema);

		var fileInformation = new FileInformation
		{
			Content = GenerateFileContent(molecularSchema),
			Name = GenerateFileName(molecularSchema),
		};

		var schemaInformation = new CreatedSchemaInformation(pocoObject.ObjectType, molecularSchema, invalidProperties);
		_configuration.Events.MoleculeSchemaCreated?.Invoke(this, new MoleculeSchemaCreatedEventArgs(schemaInformation));
		return (fileInformation, schemaInformation);
	}

	/// <summary>
	///     In order to prevent circular dependencies, we need to generate the molecule definitions first.
	/// </summary>
	private PocoObject GenerateMoleculeDefinition(PocoObject pocoObject)
	{
		if (!_generatedSchemas.ContainsKey(pocoObject.ObjectType))
		{
			_generatedSchemas.Add(pocoObject.ObjectType, new PartialMolecularZodSchema
			{
				SchemaBaseName = new SchemaBaseName(pocoObject.TypeName),
			});
		}

		return pocoObject;
	}

	private IEnumerable<FileInformation> GenerateObjects(IEnumerable<PocoObject> pocoObjects)
	{
		var definitions = pocoObjects
			.Select(GenerateMoleculeDefinition)
			.ToArray();

		_configuration.CreatedSchemasDictionary = _generatedSchemas;

		var schemas = definitions
			.Select(GenerateMolecule)
			.ToArray();

		_configuration.Events.MoleculeSchemasCreated?.Invoke(this, new MoleculeSchemasCreatedEventArgs(schemas.Select(x => x.SchemaInformation).ToArray()));

		return schemas.Select(x => x.FileInformation);
	}
}
