using System.Collections.Immutable;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Microsoft.CodeAnalysis.Text;

namespace LanguageFileParser.Generator;

// TODO: Convert to IIncrementalGenerator
// TODO: Add option to select output partial class name
[Generator]
public class LanguageFileTransformGenerator : ISourceGenerator
{
	private const string Authors = "Kenneth Hoff";

	private const string OutputPartialClassName = "Localizations"; 
	private const string FileExtension = ".xml";
	private const int TopLevelDepth = 1;


	private static readonly Regex LanguageFileRegex = new(@"^.*Resources(\\|/)LanguageFiles(\\|/).*.xml$");
	private static readonly Assembly ThisAssembly = typeof(LanguageFileTransformGenerator).Assembly;
	private static readonly Version AssemblyVersion = ThisAssembly.GetName().Version;

	private static readonly string HeaderTemplate =
		$"""
		// This file is generated by Oxx.Backend.Utils.LanguageFileParser.
		// Do not edit this file directly, instead edit the source file and regenerate this file.
		// Version: { AssemblyVersion}
		// Authors: { Authors}
		""";

	#region Interface implementations

	public void Execute(GeneratorExecutionContext context)
	{
		var languageFiles = context.AdditionalFiles
			.Where(at => LanguageFileRegex.IsMatch(at.Path))
			.ToImmutableList();

		languageFiles.ForEach(file =>
		{
			var content = file.GetText(context.CancellationToken);
			if (content is null)
			{
				return;
			}

			var elements = new List<ParsedElement>();

			var fileName = new Uri(file.Path).Segments.Last().Replace(FileExtension, string.Empty);
			var parsed = ParseXmlContent(content, fileName, elements);
			var sanitizedPath = SanitizePath(file.Path);
			context.AddSource($"{sanitizedPath}.g.cs", parsed);
		});
	}

	public void Initialize(GeneratorInitializationContext context)
	{ }

	#endregion

	private static string CreateFile(string parsed, string nameSpace)
		=> $$"""
			{{ HeaderTemplate}}

			namespace {{ nameSpace}};

			public partial class {{OutputPartialClassName}}
			{
			{{parsed}}
			}
			""";

	private static string Indent(int depth)
		=> new('\t', depth);

	private static string ParseSection(XElement element, string fileName, int depth, List<ParsedElement> parsedElements)
	{
		var name = depth == TopLevelDepth ? fileName : element.Name.LocalName;

		if (parsedElements.Any(x => x.Name == name && x.Depth == depth))
		{
			return string.Empty;
		}

		// if (element.HasAttributes)
		// {
		// 	UpdateName(ref name, element, depth);
		// }

		if (!element.HasElements)
		{
			return $"{Indent(depth)}public const string {name} = nameof({name});";
		}

		var nextDepth = depth + 1;

		var section = element.Elements().Select(element1 => ParseSection(element1, fileName, nextDepth, parsedElements)).ToList();

		parsedElements.Add(new ParsedElement(name, depth));

		return $$"""
				{{ Indent(depth)}}public class {{ name}}
				{{ Indent(depth)}}{
				{{ string.Join("\n", section.Where(x => x != string.Empty))}}
				{{ Indent(depth)}}}
				""" ;
	}

	private static string ParseXmlContent(SourceText content, string fileName, List<ParsedElement> parsedElements)
	{
		var parsed = XDocument.Parse(content.ToString());
		var languagesRoot = parsed.Root;
		var firstLanguage = languagesRoot?.Elements().FirstOrDefault();
		if (firstLanguage is null)
		{
			return string.Empty;
		}

		var recursivelyParsed = ParseSection(firstLanguage, fileName, TopLevelDepth, parsedElements);
		return CreateFile(recursivelyParsed, "LanguageFiles");
	}

	private static string SanitizePath(string filePath)
	{
		var indexOfLastBackslash = filePath.LastIndexOf('\\');
		return filePath.Substring(indexOfLastBackslash + 1);
	}
}

internal readonly record struct ParsedElement(string Name, int Depth);
