using System.Collections.Immutable;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Microsoft.CodeAnalysis.Text;

namespace LanguageFileParser.Generator;

[Generator]
public class LanguageFileTransformGenerator : ISourceGenerator
{
	private const string Authors = "Kenneth Hoff";
	private const string FileExtension = ".xml";

	private static readonly Regex LanguageFileRegex = new(@"^.*Resources(\\|/)LanguageFiles(\\|/).*.xml$");
	private static readonly Assembly ThisAssembly = typeof(LanguageFileTransformGenerator).Assembly;
	private static readonly Version AssemblyVersion = ThisAssembly.GetName().Version;

	#region Interface implementations

	public void Execute(GeneratorExecutionContext context)
	{
		// find anything that matches our files
		// var myFiles = context.AdditionalFiles.Where(x => x.Path.Contains(".xml")).ToList();

		var myFiles = context.AdditionalFiles
			.Where(at => LanguageFileRegex.IsMatch(at.Path))
			.ToImmutableList();

		myFiles.ForEach(file =>
		{
			var content = file.GetText(context.CancellationToken);
			if (content is null)
			{
				return;
			}

			var fileName = new Uri(file.Path).Segments.Last().Replace(FileExtension, string.Empty);
			var parsed = ParseXmlContent(content, fileName);
			var sanitizedPath = SanitizePath(file.Path);
			context.AddSource($"{sanitizedPath}.g.cs", parsed);
		});
	}

	public void Initialize(GeneratorInitializationContext context)
	{ }

	#endregion

	private static string CreateFile(string parsed, string nameSpace)
		=> 
			$"""
			// This file is generated by LanguageFileTransformGenerator.
			// Do not edit this file directly, instead edit the source file and regenerate this file.
			// Version: { AssemblyVersion}     
			// Authors: { Authors}     

			namespace { nameSpace};

			{ parsed}     
			""" ;

	private static string Indent(int depth)
		=> new('\t', depth);

	private static string ParseSection(XElement element, string fileName, int depth)
	{
		var name = depth == 0 ? fileName : element.Name.LocalName;
		if (!element.HasElements)
		{
			return $"{Indent(depth)}public const string {name} = nameof({name});";
		}

		var nextDepth = depth + 1;

		var section = element.Elements().Select(element1 => ParseSection(element1, fileName, nextDepth)).ToList();

		return $$"""
				{{ Indent(depth)}}public class {{ name}}    
				{{ Indent(depth)}}{
				{{ string.Join("\n", section)}}    
				{{ Indent(depth)}}}
				""" ;
	}

	private static string ParseXmlContent(SourceText content, string fileName)
	{
		var parsed = XDocument.Parse(content.ToString());
		var languagesRoot = parsed.Root;
		var firstLanguage = languagesRoot?.Elements().FirstOrDefault();
		if (firstLanguage is null)
		{
			return string.Empty;
		}

		var recursivelyParsed = ParseSection(firstLanguage, fileName, 0);
		return CreateFile(recursivelyParsed, "LanguageFiles");
	}

	private static string SanitizePath(string filePath)
	{
		var indexOfLastBackslash = filePath.LastIndexOf('\\');
		return filePath.Substring(indexOfLastBackslash + 1);
	}
}
